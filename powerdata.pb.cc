// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: powerdata.proto

#include "powerdata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace protopower {
PROTOBUF_CONSTEXPR Gauge::Gauge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vbat_)*/0
  , /*decltype(_impl_.soc_)*/0
  , /*decltype(_impl_.charging_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GaugeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GaugeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GaugeDefaultTypeInternal() {}
  union {
    Gauge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GaugeDefaultTypeInternal _Gauge_default_instance_;
PROTOBUF_CONSTEXPR Charger::Charger(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vbus_)*/0
  , /*decltype(_impl_.vsys_)*/0
  , /*decltype(_impl_.vbat_)*/0
  , /*decltype(_impl_.iin_)*/0
  , /*decltype(_impl_.ichg_)*/0
  , /*decltype(_impl_.idchg_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChargerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChargerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChargerDefaultTypeInternal() {}
  union {
    Charger _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChargerDefaultTypeInternal _Charger_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/false
  , /*decltype(_impl_.charging_)*/false
  , /*decltype(_impl_.fastcharge_)*/false
  , /*decltype(_impl_.precharge_)*/false
  , /*decltype(_impl_.faults_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
PROTOBUF_CONSTEXPR PowerData::PowerData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gauge_)*/nullptr
  , /*decltype(_impl_.charger_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PowerDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerDataDefaultTypeInternal() {}
  union {
    PowerData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerDataDefaultTypeInternal _PowerData_default_instance_;
}  // namespace protopower
namespace protopower {

// ===================================================================

class Gauge::_Internal {
 public:
};

Gauge::Gauge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protopower.Gauge)
}
Gauge::Gauge(const Gauge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Gauge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vbat_){}
    , decltype(_impl_.soc_){}
    , decltype(_impl_.charging_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vbat_, &from._impl_.vbat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.charging_) -
    reinterpret_cast<char*>(&_impl_.vbat_)) + sizeof(_impl_.charging_));
  // @@protoc_insertion_point(copy_constructor:protopower.Gauge)
}

inline void Gauge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vbat_){0}
    , decltype(_impl_.soc_){0}
    , decltype(_impl_.charging_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Gauge::~Gauge() {
  // @@protoc_insertion_point(destructor:protopower.Gauge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Gauge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Gauge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Gauge::Clear() {
// @@protoc_insertion_point(message_clear_start:protopower.Gauge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.vbat_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.charging_) -
      reinterpret_cast<char*>(&_impl_.vbat_)) + sizeof(_impl_.charging_));
  _internal_metadata_.Clear<std::string>();
}

const char* Gauge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float vbat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.vbat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float soc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.soc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool charging = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.charging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Gauge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protopower.Gauge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float vbat = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = this->_internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_vbat(), target);
  }

  // float soc = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_soc = this->_internal_soc();
  uint32_t raw_soc;
  memcpy(&raw_soc, &tmp_soc, sizeof(tmp_soc));
  if (raw_soc != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_soc(), target);
  }

  // bool charging = 3;
  if (this->_internal_charging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_charging(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protopower.Gauge)
  return target;
}

size_t Gauge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protopower.Gauge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float vbat = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = this->_internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    total_size += 1 + 4;
  }

  // float soc = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_soc = this->_internal_soc();
  uint32_t raw_soc;
  memcpy(&raw_soc, &tmp_soc, sizeof(tmp_soc));
  if (raw_soc != 0) {
    total_size += 1 + 4;
  }

  // bool charging = 3;
  if (this->_internal_charging() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Gauge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Gauge*>(
      &from));
}

void Gauge::MergeFrom(const Gauge& from) {
  Gauge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:protopower.Gauge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = from._internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    _this->_internal_set_vbat(from._internal_vbat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_soc = from._internal_soc();
  uint32_t raw_soc;
  memcpy(&raw_soc, &tmp_soc, sizeof(tmp_soc));
  if (raw_soc != 0) {
    _this->_internal_set_soc(from._internal_soc());
  }
  if (from._internal_charging() != 0) {
    _this->_internal_set_charging(from._internal_charging());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Gauge::CopyFrom(const Gauge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protopower.Gauge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gauge::IsInitialized() const {
  return true;
}

void Gauge::InternalSwap(Gauge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Gauge, _impl_.charging_)
      + sizeof(Gauge::_impl_.charging_)
      - PROTOBUF_FIELD_OFFSET(Gauge, _impl_.vbat_)>(
          reinterpret_cast<char*>(&_impl_.vbat_),
          reinterpret_cast<char*>(&other->_impl_.vbat_));
}

std::string Gauge::GetTypeName() const {
  return "protopower.Gauge";
}


// ===================================================================

class Charger::_Internal {
 public:
};

Charger::Charger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protopower.Charger)
}
Charger::Charger(const Charger& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Charger* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vbus_){}
    , decltype(_impl_.vsys_){}
    , decltype(_impl_.vbat_){}
    , decltype(_impl_.iin_){}
    , decltype(_impl_.ichg_){}
    , decltype(_impl_.idchg_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vbus_, &from._impl_.vbus_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.idchg_) -
    reinterpret_cast<char*>(&_impl_.vbus_)) + sizeof(_impl_.idchg_));
  // @@protoc_insertion_point(copy_constructor:protopower.Charger)
}

inline void Charger::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vbus_){0}
    , decltype(_impl_.vsys_){0}
    , decltype(_impl_.vbat_){0}
    , decltype(_impl_.iin_){0}
    , decltype(_impl_.ichg_){0}
    , decltype(_impl_.idchg_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Charger::~Charger() {
  // @@protoc_insertion_point(destructor:protopower.Charger)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Charger::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Charger::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Charger::Clear() {
// @@protoc_insertion_point(message_clear_start:protopower.Charger)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.vbus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.idchg_) -
      reinterpret_cast<char*>(&_impl_.vbus_)) + sizeof(_impl_.idchg_));
  _internal_metadata_.Clear<std::string>();
}

const char* Charger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float vbus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.vbus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vsys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.vsys_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vbat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.vbat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float iin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.iin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ichg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.ichg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float idchg = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.idchg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Charger::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protopower.Charger)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float vbus = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbus = this->_internal_vbus();
  uint32_t raw_vbus;
  memcpy(&raw_vbus, &tmp_vbus, sizeof(tmp_vbus));
  if (raw_vbus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_vbus(), target);
  }

  // float vsys = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vsys = this->_internal_vsys();
  uint32_t raw_vsys;
  memcpy(&raw_vsys, &tmp_vsys, sizeof(tmp_vsys));
  if (raw_vsys != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_vsys(), target);
  }

  // float vbat = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = this->_internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_vbat(), target);
  }

  // float iin = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iin = this->_internal_iin();
  uint32_t raw_iin;
  memcpy(&raw_iin, &tmp_iin, sizeof(tmp_iin));
  if (raw_iin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_iin(), target);
  }

  // float ichg = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ichg = this->_internal_ichg();
  uint32_t raw_ichg;
  memcpy(&raw_ichg, &tmp_ichg, sizeof(tmp_ichg));
  if (raw_ichg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_ichg(), target);
  }

  // float idchg = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_idchg = this->_internal_idchg();
  uint32_t raw_idchg;
  memcpy(&raw_idchg, &tmp_idchg, sizeof(tmp_idchg));
  if (raw_idchg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_idchg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protopower.Charger)
  return target;
}

size_t Charger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protopower.Charger)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float vbus = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbus = this->_internal_vbus();
  uint32_t raw_vbus;
  memcpy(&raw_vbus, &tmp_vbus, sizeof(tmp_vbus));
  if (raw_vbus != 0) {
    total_size += 1 + 4;
  }

  // float vsys = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vsys = this->_internal_vsys();
  uint32_t raw_vsys;
  memcpy(&raw_vsys, &tmp_vsys, sizeof(tmp_vsys));
  if (raw_vsys != 0) {
    total_size += 1 + 4;
  }

  // float vbat = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = this->_internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    total_size += 1 + 4;
  }

  // float iin = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iin = this->_internal_iin();
  uint32_t raw_iin;
  memcpy(&raw_iin, &tmp_iin, sizeof(tmp_iin));
  if (raw_iin != 0) {
    total_size += 1 + 4;
  }

  // float ichg = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ichg = this->_internal_ichg();
  uint32_t raw_ichg;
  memcpy(&raw_ichg, &tmp_ichg, sizeof(tmp_ichg));
  if (raw_ichg != 0) {
    total_size += 1 + 4;
  }

  // float idchg = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_idchg = this->_internal_idchg();
  uint32_t raw_idchg;
  memcpy(&raw_idchg, &tmp_idchg, sizeof(tmp_idchg));
  if (raw_idchg != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Charger::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Charger*>(
      &from));
}

void Charger::MergeFrom(const Charger& from) {
  Charger* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:protopower.Charger)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbus = from._internal_vbus();
  uint32_t raw_vbus;
  memcpy(&raw_vbus, &tmp_vbus, sizeof(tmp_vbus));
  if (raw_vbus != 0) {
    _this->_internal_set_vbus(from._internal_vbus());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vsys = from._internal_vsys();
  uint32_t raw_vsys;
  memcpy(&raw_vsys, &tmp_vsys, sizeof(tmp_vsys));
  if (raw_vsys != 0) {
    _this->_internal_set_vsys(from._internal_vsys());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vbat = from._internal_vbat();
  uint32_t raw_vbat;
  memcpy(&raw_vbat, &tmp_vbat, sizeof(tmp_vbat));
  if (raw_vbat != 0) {
    _this->_internal_set_vbat(from._internal_vbat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_iin = from._internal_iin();
  uint32_t raw_iin;
  memcpy(&raw_iin, &tmp_iin, sizeof(tmp_iin));
  if (raw_iin != 0) {
    _this->_internal_set_iin(from._internal_iin());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ichg = from._internal_ichg();
  uint32_t raw_ichg;
  memcpy(&raw_ichg, &tmp_ichg, sizeof(tmp_ichg));
  if (raw_ichg != 0) {
    _this->_internal_set_ichg(from._internal_ichg());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_idchg = from._internal_idchg();
  uint32_t raw_idchg;
  memcpy(&raw_idchg, &tmp_idchg, sizeof(tmp_idchg));
  if (raw_idchg != 0) {
    _this->_internal_set_idchg(from._internal_idchg());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Charger::CopyFrom(const Charger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protopower.Charger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Charger::IsInitialized() const {
  return true;
}

void Charger::InternalSwap(Charger* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Charger, _impl_.idchg_)
      + sizeof(Charger::_impl_.idchg_)
      - PROTOBUF_FIELD_OFFSET(Charger, _impl_.vbus_)>(
          reinterpret_cast<char*>(&_impl_.vbus_),
          reinterpret_cast<char*>(&other->_impl_.vbus_));
}

std::string Charger::GetTypeName() const {
  return "protopower.Charger";
}


// ===================================================================

class Status::_Internal {
 public:
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protopower.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Status* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , decltype(_impl_.charging_){}
    , decltype(_impl_.fastcharge_){}
    , decltype(_impl_.precharge_){}
    , decltype(_impl_.faults_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.source_, &from._impl_.source_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.faults_) -
    reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.faults_));
  // @@protoc_insertion_point(copy_constructor:protopower.Status)
}

inline void Status::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){false}
    , decltype(_impl_.charging_){false}
    , decltype(_impl_.fastcharge_){false}
    , decltype(_impl_.precharge_){false}
    , decltype(_impl_.faults_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:protopower.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Status::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:protopower.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.source_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.faults_) -
      reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.faults_));
  _internal_metadata_.Clear<std::string>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool charging = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.charging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fastcharge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fastcharge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool precharge = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.precharge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 faults = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.faults_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protopower.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool source = 1;
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_source(), target);
  }

  // bool charging = 2;
  if (this->_internal_charging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_charging(), target);
  }

  // bool fastcharge = 3;
  if (this->_internal_fastcharge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_fastcharge(), target);
  }

  // bool precharge = 4;
  if (this->_internal_precharge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_precharge(), target);
  }

  // uint32 faults = 5;
  if (this->_internal_faults() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_faults(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protopower.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protopower.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool source = 1;
  if (this->_internal_source() != 0) {
    total_size += 1 + 1;
  }

  // bool charging = 2;
  if (this->_internal_charging() != 0) {
    total_size += 1 + 1;
  }

  // bool fastcharge = 3;
  if (this->_internal_fastcharge() != 0) {
    total_size += 1 + 1;
  }

  // bool precharge = 4;
  if (this->_internal_precharge() != 0) {
    total_size += 1 + 1;
  }

  // uint32 faults = 5;
  if (this->_internal_faults() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_faults());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Status::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Status*>(
      &from));
}

void Status::MergeFrom(const Status& from) {
  Status* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:protopower.Status)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source() != 0) {
    _this->_internal_set_source(from._internal_source());
  }
  if (from._internal_charging() != 0) {
    _this->_internal_set_charging(from._internal_charging());
  }
  if (from._internal_fastcharge() != 0) {
    _this->_internal_set_fastcharge(from._internal_fastcharge());
  }
  if (from._internal_precharge() != 0) {
    _this->_internal_set_precharge(from._internal_precharge());
  }
  if (from._internal_faults() != 0) {
    _this->_internal_set_faults(from._internal_faults());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protopower.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, _impl_.faults_)
      + sizeof(Status::_impl_.faults_)
      - PROTOBUF_FIELD_OFFSET(Status, _impl_.source_)>(
          reinterpret_cast<char*>(&_impl_.source_),
          reinterpret_cast<char*>(&other->_impl_.source_));
}

std::string Status::GetTypeName() const {
  return "protopower.Status";
}


// ===================================================================

class PowerData::_Internal {
 public:
  static const ::protopower::Gauge& gauge(const PowerData* msg);
  static const ::protopower::Charger& charger(const PowerData* msg);
  static const ::protopower::Status& status(const PowerData* msg);
};

const ::protopower::Gauge&
PowerData::_Internal::gauge(const PowerData* msg) {
  return *msg->_impl_.gauge_;
}
const ::protopower::Charger&
PowerData::_Internal::charger(const PowerData* msg) {
  return *msg->_impl_.charger_;
}
const ::protopower::Status&
PowerData::_Internal::status(const PowerData* msg) {
  return *msg->_impl_.status_;
}
PowerData::PowerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protopower.PowerData)
}
PowerData::PowerData(const PowerData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PowerData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gauge_){nullptr}
    , decltype(_impl_.charger_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gauge()) {
    _this->_impl_.gauge_ = new ::protopower::Gauge(*from._impl_.gauge_);
  }
  if (from._internal_has_charger()) {
    _this->_impl_.charger_ = new ::protopower::Charger(*from._impl_.charger_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::protopower::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:protopower.PowerData)
}

inline void PowerData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gauge_){nullptr}
    , decltype(_impl_.charger_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PowerData::~PowerData() {
  // @@protoc_insertion_point(destructor:protopower.PowerData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PowerData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.gauge_;
  if (this != internal_default_instance()) delete _impl_.charger_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void PowerData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PowerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protopower.PowerData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.gauge_ != nullptr) {
    delete _impl_.gauge_;
  }
  _impl_.gauge_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.charger_ != nullptr) {
    delete _impl_.charger_;
  }
  _impl_.charger_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* PowerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protopower.Gauge gauge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gauge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protopower.Charger charger = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_charger(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protopower.Status status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protopower.PowerData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protopower.Gauge gauge = 1;
  if (this->_internal_has_gauge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::gauge(this),
        _Internal::gauge(this).GetCachedSize(), target, stream);
  }

  // .protopower.Charger charger = 2;
  if (this->_internal_has_charger()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::charger(this),
        _Internal::charger(this).GetCachedSize(), target, stream);
  }

  // .protopower.Status status = 3;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protopower.PowerData)
  return target;
}

size_t PowerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protopower.PowerData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protopower.Gauge gauge = 1;
  if (this->_internal_has_gauge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gauge_);
  }

  // .protopower.Charger charger = 2;
  if (this->_internal_has_charger()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.charger_);
  }

  // .protopower.Status status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowerData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PowerData*>(
      &from));
}

void PowerData::MergeFrom(const PowerData& from) {
  PowerData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:protopower.PowerData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gauge()) {
    _this->_internal_mutable_gauge()->::protopower::Gauge::MergeFrom(
        from._internal_gauge());
  }
  if (from._internal_has_charger()) {
    _this->_internal_mutable_charger()->::protopower::Charger::MergeFrom(
        from._internal_charger());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::protopower::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PowerData::CopyFrom(const PowerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protopower.PowerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerData::IsInitialized() const {
  return true;
}

void PowerData::InternalSwap(PowerData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerData, _impl_.status_)
      + sizeof(PowerData::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PowerData, _impl_.gauge_)>(
          reinterpret_cast<char*>(&_impl_.gauge_),
          reinterpret_cast<char*>(&other->_impl_.gauge_));
}

std::string PowerData::GetTypeName() const {
  return "protopower.PowerData";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protopower
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protopower::Gauge*
Arena::CreateMaybeMessage< ::protopower::Gauge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protopower::Gauge >(arena);
}
template<> PROTOBUF_NOINLINE ::protopower::Charger*
Arena::CreateMaybeMessage< ::protopower::Charger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protopower::Charger >(arena);
}
template<> PROTOBUF_NOINLINE ::protopower::Status*
Arena::CreateMaybeMessage< ::protopower::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protopower::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::protopower::PowerData*
Arena::CreateMaybeMessage< ::protopower::PowerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protopower::PowerData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
